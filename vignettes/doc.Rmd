---
title: "adverSCarial"
shorttitle: "Short title for headers"
author: Ghislain FIEVET <ghislain.fievet@gmail.com>
package: adverSCarial
abstract: >
  Document summary
output:
    BiocStyle::html_document:
        toc: true
        toc_depth: 2
vignette: >
  %\VignetteIndexEntry{adverSCarial}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

# Introduction
**adverSCarial is a package for generating and evaluating vulnerability to adversarial attacks on single-cell RNA sequencing classifiers.**

# Installation
```{r installation, eval=FALSE}
## Install BiocManager is necessary
if (!require("BiocManager")) {
    install.packages("BiocManager")
}
BiocManager::install('adverSCarial')
```

# Generate an adversarial attack

There are two types of adversarial attacks: `min change attack` which modifies slightly the input in order to alter the classification, and `max change attack` which introduce the largest possible perturbations to the input while still keeping the same classification.

Load libraries

```{r load libraries, message=FALSE}
library(adverSCarial)
library(TENxPBMCData)
library(randomForest)
```

Load a pbmc SingleCellExperiment and its cell type classification.

```{r min change attack, message=FALSE}
pbmc <- TENxPBMCData(dataset = "pbmc3k")
mat_pbmc <- matrixFromSCE(pbmc)

cell_types <- system.file("extdata", "pbmc3k_cell_types.tsv", package="adverSCarial")
cell_types <- read.table(cell_types, sep="\t")$cell_type
```

The package contains a random forest based classifier working on the pbmc3k dataset: `RFClassifier`. We verify it is classifying properly.

```{r first classif}
RFClassifier(mat_pbmc, cell_types, "DC")
```

We want to run attacks on the "DC" cluster but without modifying the genes used by human to make manual classification. We can find this list on [Seurat documentation](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html)

```{r markers}
# Known markers for each cell type
markers = c("IL7R", "CCR7", "CD14", "LYZ", "S100A4", "MS4A1", "CD8A", "FCGR3A", "MS4A7",
              "GNLY", "NKG7", "FCER1A", "CST3", "PPBP")
```

## Min change attack

Modify the value of a gene inside a cell cluster in order to change its classification.

The function `advMinChange` runs a dichotomic search of one gene attacks, given the cluster to attack and a type of modification. We suggest two main modifications: `perc1` replacing the value of the gene by its first percentile, and `perc99` replacing the value of the gene by its 99th percentile. The `adv_fct` argument allows users to choose custom modifications of the gene.

The `excl_genes` argument allows users to exclude certain genes from being modified. Here we exclude the genes usually used as markers of specific cell types, as defined previously.

Computation times can be lengthy, we use the `return_first_found` argument to return the result as soon as it is found.

We can specify the `change_type = "not_na"` argument to indicate that we want the attack to misclassify the cluster as an existing cell type, rather than as NA.

```{r search min change attack, message=FALSE}
adv_min_change = advMinChange(mat_pbmc, cell_types, "DC",
                        RFClassifier, excl_genes = markers, adv_method = "perc99",
                        return_first_found = TRUE, change_type = "not_na",
                        first_dichot = 10)
print(adv_min_change)
```

The function found that modifying the single gene `names(adv_min_change)[1]` with the `perc99` modification on the cluster leads to a new classification, `adv_min_change[[1]][1]`.

Let's run this attack and verify if it is successful.

First we modify the `mat_pbmc` matrix on the target cluster.

```{r run min change attack, echo=FALSE, message=FALSE}
mat_adver = advModifications(mat_pbmc, names(adv_min_change)[1], cell_types, "DC")
```

Then classify the "DC" cluster with `RFClassifier`.
```{r verify the min change attack}
RFClassifier(mat_adver, cell_types, "DC")
```


## Max change attack

Modify the maximum number of genes inside a cell cluster without altering its classification.

The function `advMaxChange` runs a dichotomic search of gene subsets, given the cluster to attack and a type of modification, such that the classification does not change.

The `max_split_size` argument is the maximum size of dichotomic slices. Set to 1 to have better results, but it will take longer to compute.

```{r search max change attack}
adv_max_change = advMaxChange(mat_pbmc, cell_types, "DC", RFClassifier,
                    excl_genes = markers, max_split_size = 1000, adv_method = "perc99")
print(dim(adv_max_change))
```

The function found `length(adv_max_change)` genes that you can modify with the `perc99` modification, and the cluster is still classified as `DC`.

Let's run this attack and verify if it is successful.

First we modify the `mat_pbmc` matrix on the target cluster, on the genes previously determined.

```{r run max change attack, echo=FALSE, message=FALSE}
mat_max_adver = advModifications(mat_pbmc, adv_max_change, cell_types, "DC")
```

Then we verify that classification is still `DC`.
```{r verify max change attack}
RFClassifier(mat_adver, cell_types, "DC")
```


# Prepare a classifier with `CHETAH`

Here we demonstrate how to implement a classifier, and take the example of `CHETAH` a Bioconductor scRNA-seq classifier.

de Kanter JK, Lijnzaad P, Candelli T, Margaritis T, Holstege FCP (2019). “CHETAH: a selective, hierarchical cell type identification method for single-cell RNA sequencing.” Nucleic Acids Research. ISSN 0305-1048, doi: 10.1093/nar/gkz543.

```{r load chetah, echo=FALSE, message=FALSE}
library(CHETAH)
```

First let's load a `train` and a `test` dataset.

```{r load train and test, echo=FALSE, message=FALSE}
# Load scRNA-seq datasets
train_3k <- TENxPBMCData(dataset = "pbmc3k")
test_4k <- TENxPBMCData(dataset = "pbmc4k")

cell_types_3k <- system.file("extdata", "pbmc3k_cell_types.tsv", package="adverSCarial")
cell_types_3k <- read.table(cell_types_3k, sep="\t")
train_3k <- train_3k[,!is.na(cell_types_3k$cell_type)]
colData(train_3k)$celltypes <- cell_types_3k$cell_type[!is.na(cell_types_3k$cell_type)]
```

Then we convert the `test` dataset into a `Seurat` object for visualization purpose.

```{r test chetah seurat object, echo=FALSE, message=FALSE}
counts4seurat <- t(matrixFromSCE(test_4k))
pbmc <- CreateSeuratObject(counts = counts4seurat, project = "pbmc4k", min.cells = 3, min.features = 200)
# Filter, normalize and find features
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
# Scale and run PCA
pbmc <- ScaleData(pbmc, features = rownames(pbmc))
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
# Cluster and visualize
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
pbmc <- RunUMAP(pbmc, dims = 1:10)
```

We annotate cells with `CHETAH`.

```{r annotate with CHETAH, echo=FALSE, message=FALSE}
# Anotation with CHETAH
reference_3k <<- sceConvertToHGNC(train_3k)
input <- SingleCellExperiment(assays = list(counts = as.matrix(pbmc@assays$RNA@counts)))
input <- CHETAHclassifier(input = input, ref_cells = reference_3k)
input <- Classify(input = input, 0.00001)
pbmc@meta.data[['chetah_classification']] <- input$celltype_CHETAH
Idents(pbmc) <- 'chetah_classification'
```

And visualize the results

```{r chetah markers}
# Known markers for each cell type
markers = c("IL7R", "CCR7", "CD14", "LYZ", "S100A4", "MS4A1", "CD8A", "FCGR3A", "MS4A7",
              "GNLY", "NKG7", "FCER1A", "CST3", "PPBP")
DotPlot(pbmc, features=markers)
```

```{r chetah dimplot}
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5)
```

## Adapt the classifier
`CHETAH` is a classifier that, when given a list of RNA values for a cell, returns a specific cell type from that list. We need to adjust the classifier so that it can assign a cell type to a group of cells.
    
A classifier function has to be formated as follow to be used with *adverSCarial*:
```R
    classifier = function(expr, clusters, target){
                
                
                c("cell type", trust_value)
    }
```
    
The matrix `expr` contains RNA expression values, the list `clusters` consists of the cluster IDs for each cell in `expr`, and `target` is the ID of the cluster for which we want to have a classification. The function returns a vector with the classification result, and a trust indice.

This is how you can adapt `CHETAH` for `adverSCarial`.
```{r chetah adapt classifier}
CHETAHClassifier = function(expr, clusters, target){
    if (!exists("reference_3k")) {
        reference_3k <<- train_3k
    }
    input <- SingleCellExperiment(assays = list(counts = t(expr)))
    input <- CHETAHclassifier(input = input, ref_cells = reference_3k)
    input <- Classify(input = input, 0.01)
    final_predictions = input$celltype_CHETAH[clusters == target]
    ratio <- as.numeric(sort(table(final_predictions), decreasing = TRUE)[1]) /
        sum(as.numeric(sort(table(final_predictions), decreasing = TRUE)))
    predicted_class <- names(sort(table(final_predictions), decreasing = TRUE)[1])
    if ( ratio < 0.3){
        predicted_class <- "NA"
    }
    c(predicted_class, ratio)
}
```

You can now test `CHETAH` classifier with `adverSCarial` tools.

Let's run a `maxChangeAttack`.

```{r chetah max change attack}
res_max_change = advMaxChange(rna_matrix, clusters_id, "DC", CHETAHClassifier,adv_method="perc99", max_split_size = 1000)
res_max_change
```

Let's run this attack and verify if it is successful.

First we modify the `mat_pbmc` matrix on the target cluster, on the genes previously determined.

```{r chetah run max change attack, echo=FALSE, message=FALSE}
mat_max_adver = advModifications(mat_pbmc, adv_max_change, cell_types, "DC")
```

Then we verify that classification is still `DC`.
```{r chetah verify max change attack}
RFClassifier(mat_adver, cell_types, "DC")
```

# Advanced attacks with `advRandWalkMinChange`

The `CHETAH` classifier is not vulenrable to one gene attack on `DC`cluster. So we can use the `advRandWalkMinChange` function to generate more complex attacks, still looking for a minimum change in the input.

First step is to look for a list o genes suscpetibles to move the classification. We get this list by using `findMarkers` function from `Seurat`.

```{r find markers}
seurat_markers <- FindMarkers(pbmc, ident.1 = "DC", ident.2="CD14+ Mono")
genes_4walk <- rownames(seurat_markers[abs(seurat_markers$avg_log2FC)>1,])
# Remove the officiel markers from the candidates
genes_4walk <- genes_4walk[!genes_4walk %in% markers]
genes_4walk
```

Then we define a list of modifications to test:
```{r list of modifications}
modifications <- list()
modifications[[1]] <- list("perc1")
modifications[[2]] <- list("perc99")
```

Then we process to a random walk parameter search on these genes and these modifications:
```{r run advRandWalkMinChange}
rand_walk_min_change <- advRandWalkMinChange(mat_pbmc, cell_types, "DC", CHETAHClassifier, genes=genes_4walk, modifications=modifications, walk_length=100)
head(rand_walk_min_change)
```

The first line of `rand_walk_min_change` contains the parameter for the attack:
```{r display attack vector}
best_results <- rand_walk_min_change_attacks[1,]
best_results <- best_results[6:ncol(best_results)]
best_results <- best_results[,best_results!="NA"]
best_results
```

Then we modify the rna expression matrix to fool the classifier:
```{r rand walk modify mat}
min_change_attack_rna_matrix <- mat_pbmc
for ( i in seq_len(length(colnames(best_results)))){
    gene2modif <- colnames(best_results)[i]
    modif <- best_results[1,i]
    min_change_attack_rna_matrix <- advModifications(min_change_attack_rna_matrix,
        gene2modif, cell_types, "DC", adv_method=modif)
}
```

And we check it successfully changed the classification.
```{r check rand walk classif}
RFClassifier(min_change_attack_rna_matrix, cell_types, "DC")
```

# Run vulnerability analysis with `minChangeOverview` and `maxChangeOverview`

The `minChangeOverview` and `maxChangeOverview` functions designed to provide insight into of the min and max change adversarial attacks on each cell type, on various gene modifications.

## Which attack to choose?
Before generating an attack it is judicious to choose the cell type to attack, and the modification susceptible to lead to a successful attack. Both functions run attack approximations, faster than the original, by studying splices of 100 genes.

## Which classifier is more vulnerable to adversarial attacks?
Sometimes we want to compare two classifiers and see which one is more vulnerable to adversarial attacks.

## Which modifications to compare

Here we define the modifications to analyse
```{r modifications for overview}
modifications <- list()
modifications[[1]] <- list("perc1")
modifications[[2]] <- list("perc99")
```

We run the `min change overview`, this gives us a general idea of which cell types are more vulnerable to min change attacks.
```{r run min change overview}
min_change_overview <- minChangeOverview(mat_pbmc, cell_types, CHETAHClassifier, modifications= modifications, max_split_size = 1000)
min_change_overview
```

And the `max change overview`, giving us a general idea of which cell types are more vulnerable to max change attacks.
```{r run max change overview}
max_change_overview <- maxChangeOverview(mat_pbmc, cell_types, CHETAHClassifier, modifications= modifications, max_split_size = 1000)
max_change_overview
```

```{r session info}
sessionInfo()
```