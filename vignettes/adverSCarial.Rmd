---
title: "adverSCarial, generate and analyze the vulnerability of scRNA-seq
    classifiers to adversarial attacks"
shorttitle: "adverSCarial"
author: Ghislain FIEVET <ghislain.fievet@gmail.com>
package: adverSCarial
abstract: >
    adverSCarial is an R Package designed for generating and analyzing the vulnerability of scRNA-seq
    classifiers to adversarial attacks. The package is versatile and provides a format for integrating
    any type of classifier. It offers functions for studying and generating two types of attacks,
    min change attack and max change attack. The min change attack involves making a small modification
    to the input to alter the classification. The max change attack involves making a large modification
    to the input without changing its classification.
    The package provides a comprehensive solution for evaluating the robustness of scRNA-seq classifiers
    against adversarial attacks.
output:
    BiocStyle::html_document:
        toc: true
        toc_depth: 2
vignette: >
  %\VignetteIndexEntry{adverSCarial}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

# Introduction
**adverSCarial is a package for generating and evaluating vulnerability to adversarial attacks on single-cell RNA sequencing classifiers.**

# Installation
```{r installation, eval=FALSE}
## Install BiocManager is necessary
if (!require("BiocManager")) {
    install.packages("BiocManager")
}
BiocManager::install('adverSCarial')
```

# Generate an adversarial attack

There are two types of adversarial attacks: `min change attack` which modifies slightly the input in order to alter the classification, and `max change attack` which introduce the largest possible perturbations to the input while still keeping the same classification.

Load libraries

```{r load libraries, warning = FALSE, message=FALSE}
library(adverSCarial)
library(TENxPBMCData)
library(randomForest)
```

Load a pbmc SingleCellExperiment and its cell type classification.

```{r min change attack, message=FALSE, warning = FALSE, cache = TRUE}
pbmc <- TENxPBMCData(dataset = "pbmc3k")
mat_pbmc <- matrixFromSCE(pbmc)

cell_types <- system.file("extdata", "pbmc3k_cell_types.tsv", package="adverSCarial")
cell_types <- read.table(cell_types, sep="\t")$cell_type
```

The package contains a random forest based classifier working on the pbmc3k dataset: `RFClassifier`. We verify it is classifying properly.

```{r first classif, message=FALSE}
res_classif <- RFClassifier(mat_pbmc, cell_types, "DC")
```
```{r first classif bis}
res_classif
```

We want to run attacks on the "DC" cluster but without modifying the genes used by human to make manual classification. We can find this list on [Seurat documentation](https://satijalab.org/seurat/articles/pbmc3k_tutorial.html)

```{r markers}
# Known markers for each cell type
markers = c("IL7R", "CCR7", "CD14", "LYZ", "S100A4", "MS4A1", "CD8A", "FCGR3A", "MS4A7",
              "GNLY", "NKG7", "FCER1A", "CST3", "PPBP")
```

## Min change attack

Modify the value of a gene inside a cell cluster in order to change its classification.

The function `advMinChange` runs a dichotomic search of one gene attacks, given the cluster to attack and a type of modification. We suggest two main modifications: `perc1` replacing the value of the gene by its first percentile, and `perc99` replacing the value of the gene by its 99th percentile. The `adv_fct` argument allows users to choose custom modifications of the gene.

The `excl_genes` argument allows users to exclude certain genes from being modified. Here we exclude the genes usually used as markers of specific cell types, as defined previously.

Computation times can be lengthy, we use the `return_first_found` argument to return the result as soon as it is found.

We can specify the `change_type = "not_na"` argument to indicate that we want the attack to misclassify the cluster as an existing cell type, rather than as NA.

```{r search min change attack, message=FALSE, cache = TRUE, warning = FALSE}
adv_min_change = advMinChange(mat_pbmc, cell_types, "DC",
                        RFClassifier, excl_genes = markers, adv_method = "perc99",
                        return_first_found = TRUE, change_type = "not_na",
                        first_dichot = 10)
```
```{r search min change attack bis, cache = TRUE, warning = FALSE}
adv_min_change
```

The function found that modifying the single gene `names(adv_min_change)[1]` with the `perc99` modification on the cluster leads to a new classification, `adv_min_change[[1]][1]`.

Let's run this attack and verify if it is successful.

First we modify the `mat_pbmc` matrix on the target cluster.

```{r run min change attack, message=FALSE, cache = TRUE, warning = FALSE}
mat_adver <- advModifications(mat_pbmc, names(adv_min_change)[1], cell_types, "DC")
```

Then classify the "DC" cluster with `RFClassifier`.
```{r verify the min change attack, cache = TRUE, warning = FALSE, message = FALSE}
rf_result <- RFClassifier(mat_adver, cell_types, "DC")
```
```{r verify the min change attack bis, cache = TRUE, warning = FALSE}
rf_result
```

## Max change attack

Modify the maximum number of genes inside a cell cluster without altering its classification.

The function `advMaxChange` runs a dichotomic search of gene subsets, given the cluster to attack and a type of modification, such that the classification does not change.

The `max_split_size` argument is the maximum size of dichotomic slices. Set to 1 to have better results, but it will take longer to compute.

```{r search max change attack, cache = TRUE, warning = FALSE, message=FALSE}
adv_max_change <- advMaxChange(mat_pbmc, cell_types, "DC", RFClassifier,
                    excl_genes = markers, max_split_size = 1000, adv_method = "perc99")
```
```{r search max change attack bis, cache = TRUE, warning = FALSE}
dim(adv_max_change)
```


The function found `length(adv_max_change)` genes that you can modify with the `perc99` modification, and the cluster is still classified as `DC`.

Let's run this attack and verify if it is successful.

First we modify the `mat_pbmc` matrix on the target cluster, on the genes previously determined.

```{r run max change attack, message=FALSE, cache = TRUE, warning=FALSE}
mat_max_adver <- advModifications(mat_pbmc, adv_max_change, cell_types, "DC")
```

Then we verify that classification is still `DC`.
```{r verify max change attack, warning = FALSE, cache = TRUE, message=FALSE}
res_classif <- RFClassifier(mat_adver, cell_types, "DC")
```
```{r verify max change attack bis, warning = FALSE, cache = TRUE}
res_classif
```

# Prepare a classifier with `CHETAH`

Here we demonstrate how to implement a classifier, and take the example of `CHETAH` a Bioconductor scRNA-seq classifier.

de Kanter JK, Lijnzaad P, Candelli T, Margaritis T, Holstege FCP (2019). “CHETAH: a selective, hierarchical cell type identification method for single-cell RNA sequencing.” Nucleic Acids Research. ISSN 0305-1048, doi: 10.1093/nar/gkz543.

```{r load chetah, message=FALSE, warning=FALSE }
library(CHETAH)
library(Seurat)
```

First let's load a `train` and a `test` dataset.

```{r load train and test, message=FALSE, warning = FALSE, cache = TRUE}
# Load scRNA-seq datasets
train_3k <- TENxPBMCData(dataset = "pbmc3k")
test_4k <- TENxPBMCData(dataset = "pbmc4k")

cell_types_3k <- system.file("extdata", "pbmc3k_cell_types.tsv", package="adverSCarial")
cell_types_3k <- read.table(cell_types_3k, sep="\t")
train_3k <- train_3k[,!is.na(cell_types_3k$cell_type)]
colData(train_3k)$celltypes <- cell_types_3k$cell_type[!is.na(cell_types_3k$cell_type)]
```

Then we convert the `test` dataset into a `Seurat` object for visualization purpose.

```{r test chetah seurat object, message=FALSE, warning = FALSE, cache = TRUE}
counts4seurat <- t(matrixFromSCE(test_4k))
pbmc <- CreateSeuratObject(counts = counts4seurat, project = "pbmc4k", min.cells = 3, min.features = 200)
# Filter, normalize and find features
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
# Scale and run PCA
pbmc <- ScaleData(pbmc, features = rownames(pbmc))
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
# Cluster and visualize
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
pbmc <- RunUMAP(pbmc, dims = 1:10)
```

We annotate cells with `CHETAH`.

```{r annotate with CHETAH, message=FALSE, warning = FALSE, cache = TRUE}
# Anotation with CHETAH
reference_3k <<- sceConvertToHGNC(train_3k)
input <- SingleCellExperiment(assays = list(counts = as.matrix(pbmc@assays$RNA@counts)))
input <- CHETAHclassifier(input = input, ref_cells = reference_3k)
input <- Classify(input = input, 0.00001)
pbmc@meta.data[['chetah_classification']] <- input$celltype_CHETAH
Idents(pbmc) <- 'chetah_classification'
```

And visualize the results

```{r chetah markers, warning = FALSE, cache = TRUE}
# Known markers for each cell type
markers = c("IL7R", "CCR7", "CD14", "LYZ", "S100A4", "MS4A1", "CD8A", "FCGR3A", "MS4A7",
              "GNLY", "NKG7", "FCER1A", "CST3", "PPBP")
DotPlot(pbmc, features=markers)
```

```{r chetah dimplot, warning = FALSE, cache = TRUE}
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5)
```

## Adapt the classifier
`CHETAH` is a classifier that, when given a list of RNA values for a cell, returns a specific cell type from that list. We need to adjust the classifier so that it can assign a cell type to a group of cells.
    
A classifier function has to be formated as follow to be used with *adverSCarial*:
```R
    classifier = function(expr, clusters, target){
                
                
                c("cell type", trust_value)
    }
```
    
The matrix `expr` contains RNA expression values, the list `clusters` consists of the cluster IDs for each cell in `expr`, and `target` is the ID of the cluster for which we want to have a classification. The function returns a vector with the classification result, and a trust indice.

This is how you can adapt `CHETAH` for `adverSCarial`.
```{r chetah adapt classifier, warning = FALSE, cache = TRUE, message=FALSE}
CHETAHClassifier <- function(expr, clusters, target){
    if (!exists("reference_3k")) {
        reference_3k <<- train_3k
    }
    input <- SingleCellExperiment(assays = list(counts = t(expr)))
    input <- CHETAHclassifier(input = input, ref_cells = reference_3k)
    input <- Classify(input = input, 0.01)
    final_predictions = input$celltype_CHETAH[clusters == target]
    ratio <- as.numeric(sort(table(final_predictions), decreasing = TRUE)[1]) /
        sum(as.numeric(sort(table(final_predictions), decreasing = TRUE)))
    predicted_class <- names(sort(table(final_predictions), decreasing = TRUE)[1])
    if ( ratio < 0.3){
        predicted_class <- "NA"
    }
    c(predicted_class, ratio)
}
```

You can now test `CHETAH` classifier with `adverSCarial` tools.

Let's run a `maxChangeAttack`.

```{r chetah max change attack, warning = FALSE, cache = TRUE, message=FALSE}
rna_matrix <- t(as.matrix(pbmc@assays$RNA@counts))
clusters_id <- pbmc@meta.data[['chetah_classification']]
adv_max_change <- advMaxChange(rna_matrix, clusters_id, "DC", CHETAHClassifier,adv_method="perc99", max_split_size = 1000)
```


Let's run this attack and verify if it is successful.

First we modify the `mat_pbmc` matrix on the target cluster, on the genes previously determined.

```{r chetah run max change attack, message=FALSE, warning = FALSE, cache = TRUE}
mat_max_adver <- advModifications(rna_matrix, adv_max_change, clusters_id, "DC")
```

Then we verify that classification is still `DC`.
```{r chetah verify max change attack, warning = FALSE, cache = TRUE, message=FALSE}
rf_result <- RFClassifier(mat_max_adver, clusters_id, "DC")
```
```{r chetah verify max change attack bis, warning = FALSE, cache = TRUE}
rf_result
```


```{r session info}
sessionInfo()
```